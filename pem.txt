------------------------PARITY/CRC/HAMMING-------------------------
#include <iostream>
#include <cstring>
using namespace std;

// ------------ EVEN PARITY ERROR CHECK ------------
void parityCheck() {
    char sent[50], received[50];

    cout << "\nEnter SENT data bits: ";
    cin >> sent;

    cout << "Enter RECEIVED data bits: ";
    cin >> received;

    int countSent = 0, countRecv = 0;

    for (int i = 0; sent[i] != '\0'; i++)
        if (sent[i] == '1') countSent++;

    for (int i = 0; received[i] != '\0'; i++)
        if (received[i] == '1') countRecv++;

    cout << "\nSent     : " << sent << endl;
    cout << "Received : " << received << endl;

    // EVEN parity check
    if (countSent % 2 == countRecv % 2)
        cout << "Even Parity: No error detected.\n";
    else
        cout << "Even Parity: Error detected!\n";

    // locate bit position mismatch
    int pos = -1;
    int len = strlen(sent);

    for (int i = 0; i < len; i++) {
        if (sent[i] != received[i]) {
            pos = i + 1;
            break;
        }
    }

    if (pos != -1)
        cout << "Error located at bit position: " << pos << endl;
    else
        cout << "No bit position mismatch.\n";
}


// ------------ CRC ERROR CHECK ------------
void crcCheck() {
    char sent[100], received[100], divisor[20], temp[100];
    int i, j;

    cout << "\nEnter SENT data+CRC: ";
    cin >> sent;

    cout << "Enter RECEIVED data+CRC: ";
    cin >> received;

    cout << "Enter generator polynomial (e.g. 1101): ";
    cin >> divisor;

    strcpy(temp, received);

    int datalen = strlen(temp);
    int divlen = strlen(divisor);

    for (i = 0; i <= datalen - divlen; i++) {
        if (temp[i] == '1') {
            for (j = 0; j < divlen; j++)
                temp[i + j] = (temp[i + j] == divisor[j]) ? '0' : '1';
        }
    }

    bool error = false;
    for (i = datalen - divlen + 1; i < datalen; i++)
        if (temp[i] == '1') error = true;

    if (error) {
        cout << "CRC: Error detected!" << endl;

        int pos = -1;
        for (i = 0; sent[i] != '\0'; i++)
            if (sent[i] != received[i]) { pos = i + 1; break; }

        if (pos != -1)
            cout << "Error at bit position: " << pos << endl;
    }
    else
        cout << "CRC: No error detected.\n";
}


// ------------ HAMMING (7,4) CODE WITH ERROR DETECTION & CORRECTION ------------
void hammingCheck() {
    int d[4], p[3], r[7];

    cout << "\nEnter 4 data bits (d1 d2 d3 d4): ";
    cin >> d[0] >> d[1] >> d[2] >> d[3];

    // Parity bits (your formula)
    p[0] = d[0] ^ d[1] ^ d[3];  // p1
    p[1] = d[0] ^ d[2] ^ d[3];  // p2
    p[2] = d[1] ^ d[2] ^ d[3];  // p4

    cout << "Generated Hamming code (p1 p2 d1 p4 d2 d3 d4): ";
    cout << p[0] << p[1] << d[0] << p[2] << d[1] << d[2] << d[3] << endl;

    cout << "\nEnter received 7 bits: ";
    for (int i = 0; i < 7; i++) cin >> r[i];

    // Syndrome bits
    int c1 = r[0] ^ r[2] ^ r[4] ^ r[6];
    int c2 = r[1] ^ r[2] ^ r[5] ^ r[6];
    int c3 = r[3] ^ r[4] ^ r[5] ^ r[6];

    int errorPos = c1 + 2 * c2 + 4 * c3;

    if (errorPos == 0)
        cout << "No error.\n";
    else {
        cout << "Error at position: " << errorPos << endl;
        r[errorPos - 1] ^= 1;   // correct the bit

        cout << "Corrected code: ";
        for (int i = 0; i < 7; i++) cout << r[i];
        cout << endl;
    }
}


// ------------ MAIN MENU ------------
int main() {
    int ch;

    while (true) {
        cout << "\n===== MENU =====\n";
        cout << "1. Even Parity Check\n";
        cout << "2. CRC Check\n";
        cout << "3. Hamming Code (7,4)\n";
        cout << "4. Exit\n";
        cout << "Enter choice: ";
        cin >> ch;

        switch (ch) {
            case 1: parityCheck(); break;
            case 2: crcCheck(); break;
            case 3: hammingCheck(); break;
            case 4: return 0;
            default: cout << "Invalid choice\n";
        }
    }
}
------------------------------------STOP&WAIT/GOBACKN/SELECTIVEARQ-----------------------------------
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

// RANDOM ACK GENERATOR (0 = NACK, 1 = ACK)
int randomACK() {
    return rand() % 2;
}

// ---------------- STOP & WAIT ARQ ----------------
void stopAndWait() {
    int frames;
    cout << "\nEnter number of frames to send: ";
    cin >> frames;

    for(int i = 1; i <= frames; i++) {
        cout << "\nSender: Sending Frame " << i << endl;

        int ack = randomACK();
        if(ack == 1) {
            cout << "Receiver: ACK received for Frame " << i << endl;
        } else {
            cout << "Receiver: NACK (Frame " << i << " lost). Resending..." << endl;
            i--;  // resend frame
        }
    }
    cout << "\nAll frames sent successfully using Stop-and-Wait ARQ!\n";
}

// ---------------- GO BACK N ARQ ----------------
void goBackN() {
    int frames, window;
    cout << "\nEnter number of frames: ";
    cin >> frames;
    cout << "Enter window size: ";
    cin >> window;

    int i = 1;

    while(i <= frames) {
        cout << "\nSender: Sending window frames: ";
        for(int j = i; j < i + window && j <= frames; j++) {
            cout << j << " ";
        }
        cout << endl;

        int errorFrame = randomACK(); // random error
        if(errorFrame == 0) {
            cout << "Receiver: Error detected! ACK not received." << endl;
            cout << "Sender: Going back and resending window...\n";
            // resend same window
        } else {
            cout << "Receiver: ACK received for window.\n";
            i += window; // move window forward
        }
    }

    cout << "\nAll frames sent successfully using Go-Back-N ARQ!\n";
}

// ---------------- SELECTIVE REPEAT ARQ ----------------
void selectiveRepeat() {
    int frames, window;
    cout << "\nEnter number of frames: ";
    cin >> frames;
    cout << "Enter window size: ";
    cin >> window;

    int received[100] = {0}; // stores ACK status

    for(int i = 1; i <= frames; i++) {
        cout << "\nSender: Sending Frame " << i << endl;

        int ack = randomACK();

        if(ack == 1) {
            cout << "Receiver: ACK received for Frame " << i << endl;
            received[i] = 1;
        } else {
            cout << "Receiver: NACK (Frame " << i << " lost)" << endl;
            received[i] = 0;
        }
    }

    cout << "\nSelective retransmission of only failed frames...\n";

    for(int i = 1; i <= frames; i++) {
        if(received[i] == 0) {
            cout << "Resending Frame " << i << endl;

            int ack = randomACK();
            if(ack == 1) {
                cout << "Receiver: ACK received for Frame " << i << endl;
                received[i] = 1;
            } else {
                cout << "Still NACK. Sending again...\n";
                i--;  // resend again
            }
        }
    }

    cout << "\nAll frames sent successfully using Selective Repeat ARQ!\n";
}

// ---------------- MAIN MENU ----------------
int main() {
    srand(time(0)); // random seed

    int choice;

    while(true) {
        cout << "\n====== SLIDING WINDOW ARQ SIMULATOR ======\n";
        cout << "1. Stop and Wait ARQ\n";
        cout << "2. Go Back N ARQ\n";
        cout << "3. Selective Repeat ARQ\n";
        cout << "4. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;

        switch(choice) {
            case 1: stopAndWait(); break;
            case 2: goBackN(); break;
            case 3: selectiveRepeat(); break;
            case 4: return 0;
            default: cout << "Invalid choice!\n";
        }
    }
}

--------------------------------------------SUBNETCALCULATOR------------------------------------------------
#include <iostream>
#include <cmath>
#include <sstream>
using namespace std;

// Parse IP string into int array
void parseIP(const string& ip, int parts[4]) {
    sscanf(ip.c_str(), "%d.%d.%d.%d", &parts[0], &parts[1], &parts[2], &parts[3]);
}

// Convert int array to string
string ipToString(int ip[4]) {
    stringstream ss;
    ss << ip[0] << "." << ip[1] << "." << ip[2] << "." << ip[3];
    return ss.str();
}

// Add increment to IP
void incrementIP(int ip[4], int inc) {
    int carry = inc;
    for (int i = 3; i >= 0 && carry > 0; i--) {
        int total = ip[i] + carry;
        ip[i] = total % 256;
        carry = total / 256;
    }
}

// Convert prefix ? subnet mask
void prefixToMask(int prefix, int mask[4]) {
    for (int i = 0; i < 4; i++) mask[i] = 0;

    for (int i = 0; i < prefix; i++)
        mask[i/8] |= (128 >> (i % 8));
}

// Calculate prefix from host requirement
int calculatePrefix(int hosts) {
    int bits = ceil(log2(hosts + 2)); // +2 for network & broadcast
    return 32 - bits;
}

int main() {
    int numNetworks, hostsPerNetwork;
    string baseIP;

    cout << "Enter number of networks: ";
    cin >> numNetworks;

    cout << "Enter number of systems per network: ";
    cin >> hostsPerNetwork;

    cout << "Enter base network IP (e.g., 192.168.0.0): ";
    cin >> baseIP;

    int currentIP[4];
    parseIP(baseIP, currentIP);

    int prefix = calculatePrefix(hostsPerNetwork);
    int mask[4];
    prefixToMask(prefix, mask);

    int blockSize = pow(2, 32 - prefix);

    cout << "\n--- Subnet Details ---\n";
    cout << "Hosts per network: " << hostsPerNetwork 
         << "  Prefix: /" << prefix << endl << endl;

    for (int net = 0; net < numNetworks; net++) {

        int startIP[4], endIP[4], network[4], broadcast[4];
        for (int i = 0; i < 4; i++)
            startIP[i] = currentIP[i];

        // Network address = current & mask
        for (int i = 0; i < 4; i++)
            network[i] = startIP[i] & mask[i];

        // End IP = start + blockSize - 1
        incrementIP(currentIP, blockSize - 1);
        for (int i = 0; i < 4; i++)
            endIP[i] = currentIP[i];

        // Broadcast = network | (255 - mask)
        for (int i = 0; i < 4; i++)
            broadcast[i] = network[i] | (255 - mask[i]);

        // First Host = network + 1
        int firstHost[4];
        for (int i = 0; i < 4; i++)
            firstHost[i] = network[i];
        firstHost[3]++;

        // Last Host = broadcast - 1
        int lastHost[4];
        for (int i = 0; i < 4; i++)
            lastHost[i] = broadcast[i];
        lastHost[3]--;

        int totalHosts = pow(2, 32 - prefix) - 2;

        cout << "Network " << net + 1 << ":\n";
        cout << "IP Range:          " << ipToString(startIP) << " - " << ipToString(endIP) << endl;
        cout << "Network Address:   " << ipToString(network) << endl;
        cout << "Broadcast Address: " << ipToString(broadcast) << endl;
        cout << "First Host:        " << ipToString(firstHost) << endl;
        cout << "Last Host:         " << ipToString(lastHost) << endl;
        cout << "Subnet Mask:       " << ipToString(mask) << endl;
        cout << "Total Hosts:       " << totalHosts << endl;
        cout << "-----------------------------------\n";

        // Move to next subnet start
        incrementIP(currentIP, 1);
    }

    return 0;
}
-------------------------------------DVR AND LSR----------------------------------------------------------
#include <iostream>
using namespace std;

#define INF 999

void DVR(int n, int cost[10][10]) {
    int dist[10][10], nextHop[10][10];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = cost[i][j];
            nextHop[i][j] = j;
        }
    }

    int updated;
    do {
        updated = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    if (dist[i][j] > cost[i][k] + dist[k][j]) {
                        dist[i][j] = cost[i][k] + dist[k][j];
                        nextHop[i][j] = k;
                        updated = 1;
                    }
                }
            }
        }
    } while (updated);

    cout << "\n--- Distance Vector Routing Table ---\n";
    for (int i = 0; i < n; i++) {
        cout << "Router " << i + 1 << ":\n";
        for (int j = 0; j < n; j++) {
            cout << "To " << j + 1 << " via " << nextHop[i][j] + 1
                 << " distance = " << dist[i][j] << endl;
        }
        cout << endl;
    }
}

void LSR(int n, int cost[10][10]) {
    for (int src = 0; src < n; src++) {
        int dist[10], visited[10];
        for (int i = 0; i < n; i++) {
            dist[i] = cost[src][i];
            visited[i] = 0;
        }
        dist[src] = 0;
        visited[src] = 1;

        for (int count = 1; count < n - 1; count++) {
            int min = INF, u = -1;
            for (int i = 0; i < n; i++)
                if (!visited[i] && dist[i] < min) {
                    min = dist[i];
                    u = i;
                }
            visited[u] = 1;
            for (int v = 0; v < n; v++) {
                if (!visited[v] && dist[v] > dist[u] + cost[u][v])
                    dist[v] = dist[u] + cost[u][v];
            }
        }
        cout << "\nRouting Table for Node " << src + 1 << ":\n";
        for (int i = 0; i < n; i++)
            cout << "To " << i + 1 << " distance = " << dist[i] << endl;
    }
}

int main() {
    int n, choice;
    int cost[10][10];
    char ch;

    cout << "Enter number of nodes: ";
    cin >> n;

    cout << "Enter cost matrix (use 999 for no direct link):\n";
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> cost[i][j];
        }
    }

   do{
     cout << "\nSelect Routing Algorithm:\n";
    cout << "1. Distance Vector Routing (DVR)\n";
    cout << "2. Link State Routing (LSR)\n";
    cout << "Enter your choice: ";
    cin >> choice;

    switch (choice) {
        case 1:
            DVR(n, cost);
            break;
        case 2:
            LSR(n, cost);
            break;
        default:
            cout << "Invalid choice!";
    }
    cout<<"do you want to continue(y/n): ";
    cin>>ch;
   }while(ch == 'y' || ch == 'Y');

    return 0;
}

-------------------------------------------------------------------tcp server----------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

int main() {
    int sock, client;
    char message[2000];
    struct sockaddr_in server, client_addr;
    int addr_len = sizeof(client_addr);

    sock = socket(AF_INET, SOCK_STREAM, 0);
    printf("TCP Server Started...\n");

    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(8080);

    bind(sock, (struct sockaddr *)&server, sizeof(server));
    listen(sock, 3);

    printf("Waiting for client...\n");
    client = accept(sock, (struct sockaddr *)&client_addr, &addr_len);
    printf("Client Connected.\n");

    recv(client, message, 2000, 0);
    printf("Client: %s\n", message);

    send(client, "Message Received by Server", 27, 0);

    return 0;
}
--------------------------------tcp client---------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

int main() {
    int sock;
    char server_reply[2000];
    struct sockaddr_in server;

    sock = socket(AF_INET, SOCK_STREAM, 0);

    server.sin_addr.s_addr = inet_addr("127.0.0.1");
    server.sin_family = AF_INET;
    server.sin_port = htons(8080);

    connect(sock, (struct sockaddr *)&server, sizeof(server));

    send(sock, "Hello Server, this is TCP Client", 32, 0);
    recv(sock, server_reply, 2000, 0);

    printf("Server: %s\n", server_reply);

    return 0;
}
------------------------------------------------------------udp server---------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

int main() {
    int sock;
    char buffer[2000];
    struct sockaddr_in server, client;
    int client_len = sizeof(client);

    sock = socket(AF_INET, SOCK_DGRAM, 0);

    server.sin_family = AF_INET;
    server.sin_addr.s_addr = INADDR_ANY;
    server.sin_port = htons(9090);

    bind(sock, (struct sockaddr *)&server, sizeof(server));

    printf("UDP Server Running...\n");

    recvfrom(sock, buffer, 2000, 0, (struct sockaddr *)&client, &client_len);
    printf("Client: %s\n", buffer);

    sendto(sock, "Message received by UDP Server", 30, 0,
           (struct sockaddr *)&client, client_len);

    return 0;
}
------------------------------------------------------------------udp client----------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

int main() {
    int sock;
    char buffer[2000];
    struct sockaddr_in server;

    sock = socket(AF_INET, SOCK_DGRAM, 0);

    server.sin_addr.s_addr = inet_addr("127.0.0.1");
    server.sin_family = AF_INET;
    server.sin_port = htons(9090);

    sendto(sock, "Hello UDP Server", 17, 0,
           (struct sockaddr *)&server, sizeof(server));

    int len = sizeof(server);
    recvfrom(sock, buffer, 2000, 0, (struct sockaddr *)&server, &len);

    printf("Server: %s\n", buffer);

    return 0;
}
-------------------------------------------------------------------------------------------------------------------------------------------------------
