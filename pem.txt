
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

// ---------------- HAMMING CODE (7,4) ----------------

int parityCalc(int a, int b, int c) {
    return a ^ b ^ c;
}

void hammingCode() {
    vector<int> data(4), h(7), recv(7);

    cout << "\nEnter 4 data bits (d1 d2 d3 d4): ";
    for (int i = 0; i < 4; i++)
        cin >> data[i];

    // Assign data bits
    h[2] = data[0];
    h[4] = data[1];
    h[5] = data[2];
    h[6] = data[3];

    // Parity bits
    h[0] = parityCalc(h[2], h[4], h[6]);
    h[1] = parityCalc(h[2], h[5], h[6]);
    h[3] = parityCalc(h[4], h[5], h[6]);

    cout << "\nGenerated Hamming Code: ";
    for (int i = 0; i < 7; i++)
        cout << h[i] << " ";

    cout << "\n\nEnter received 7 bits: ";
    for (int i = 0; i < 7; i++)
        cin >> recv[i];

    // Syndrome
    int s1 = parityCalc(recv[2], recv[4], recv[6]) ^ recv[0];
    int s2 = parityCalc(recv[2], recv[5], recv[6]) ^ recv[1];
    int s4 = parityCalc(recv[4], recv[5], recv[6]) ^ recv[3];

    int errorPos = s4 * 4 + s2 * 2 + s1;

    if (errorPos == 0) {
        cout << "\nNo error detected.\n";
    } else {
        cout << "\nError at bit position: " << errorPos << endl;
        recv[errorPos - 1] ^= 1;

        cout << "Corrected code: ";
        for (int i = 0; i < 7; i++)
            cout << recv[i] << " ";
        cout << endl;
    }
}

// ---------------- PARITY CHECK ----------------

void parityCheck() {
    int n, bit, count = 0, parity;
    cout << "\nEnter number of bits: ";
    cin >> n;

    cout << "Enter bits: ";
    for (int i = 0; i < n; i++) {
        cin >> bit;
        if (bit == 1) count++;
    }

    cout << "Enter received parity bit: ";
    cin >> parity;

    if ((count % 2 == 0 && parity == 0) || 
        (count % 2 == 1 && parity == 1))
        cout << "NO ERROR.\n";
    else
        cout << "ERROR DETECTED.\n";
}

// ---------------- CRC ----------------

void xorOp(char *a, const char *b) {
    for (int i = 0; i < strlen(b); i++)
        a[i] = (a[i] == b[i]) ? '0' : '1';
}

void crc() {
    char data[50], div[20], temp[50];

    cout << "\nEnter data bits: ";
    cin >> data;
    cout << "Enter divisor: ";
    cin >> div;

    strcpy(temp, data);

    int dl = strlen(div);
    int len = strlen(data);

    // Append zeros
    for (int i = 0; i < dl - 1; i++)
        temp[len + i] = '0';
    temp[len + dl - 1] = '\0';

    for (int i = 0; i <= len; i++)
        if (temp[i] == '1')
            xorOp(temp + i, div);

    cout << "CRC Remainder: ";
    for (int i = len; i < len + dl - 1; i++)
        cout << temp[i];

    cout << endl;
}

// ---------------- MAIN MENU ----------------

int main() {
    int choice;
    char ch;

    do {
        cout << "\n========= ERROR CONTROL MENU =========\n";
        cout << "1. Hamming Code (7,4)\n";
        cout << "2. Parity Check\n";
        cout << "3. CRC\n";
        cout << "4. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;

        switch (choice) {
            case 1: hammingCode(); break;
            case 2: parityCheck(); break;
            case 3: crc(); break;
            case 4: return 0;
            default: cout << "Invalid choice.\n";
        }

        cout << "\nDo you want to continue? (y/n): ";
        cin >> ch;

    } while (ch == 'y' || ch == 'Y');

    return 0;
}
_________________________________________________________________________________________________________________________________________________________________________________________
SLIDING WINDOW
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

void stopAndWaitARQ() {
    int totalFrames;
    cout << "\nEnter total number of frames to send: ";
    cin >> totalFrames;
    srand(time(0));

    for (int i = 1; i <= totalFrames; i++) {
        cout << "\nSending Frame " << i << "..." << endl;
        int ack = rand() % 2; 

        if (ack) {
            cout << "Acknowledgment received for Frame " << i << endl;
        } else {
            cout << "Frame " << i << " lost! Resending..." << endl;
            cout << "Acknowledgment received for Frame " << i << endl;
        }
    }
    cout << "\nAll frames sent successfully using Stop and Wait ARQ!" << endl;
}

void goBackNARQ() {
    int totalFrames, windowSize;
    cout << "\nEnter total number of frames: ";
    cin >> totalFrames;
    cout << "Enter window size: ";
    cin >> windowSize;
    srand(time(0));

    int sent = 1;
    while (sent <= totalFrames) {
        cout << "\nSending frames: ";
        for (int i = sent; i < sent + windowSize && i <= totalFrames; i++) {
            cout << i << " ";
        }
        cout << endl;

        bool allAcked = true;
        int lostFrame = -1;

        for (int i = sent; i < sent + windowSize && i <= totalFrames; i++) {
            int status = rand() % 2; 
            if (status) {
                cout << "Acknowledgment received for Frame " << i << endl;
            } else {
                cout << "Frame " << i << " lost!" << endl;
                lostFrame = i;
                allAcked = false;
                break; 
            }
        }

        if (allAcked) {
            sent += windowSize;
        } else {
            cout << "Go back and resend from Frame " << lostFrame << endl;
            sent = lostFrame;
        }
    }

    cout << "\nAll frames sent successfully using Go-Back-N ARQ!" << endl;
}

void selectiveRepeatARQ() {
    int totalFrames, windowSize;
    cout << "\nEnter total number of frames: ";
    cin >> totalFrames;
    cout << "Enter window size: ";
    cin >> windowSize;
    srand(time(0));

    bool ack[100] = {false};

    for (int i = 1; i <= totalFrames; i += windowSize) {
        cout << "\nSending window: ";
        for (int j = i; j < i + windowSize && j <= totalFrames; j++) {
            cout << j << " ";
        }
        cout << endl;

        for (int j = i; j < i + windowSize && j <= totalFrames; j++) {
            int received = rand() % 2; 
            if (received) {
                cout << "Acknowledgment received for Frame " << j << endl;
                ack[j] = true;
            } else {
                cout << "Frame " << j << " lost!" << endl;
            }
        }

        for (int j = i; j < i + windowSize && j <= totalFrames; j++) {
            if (!ack[j]) {
                cout << "Resending Frame " << j << endl;
                cout << "Acknowledgment received for Frame " << j << endl;
                ack[j] = true;
            }
        }
    }

    cout << "\nAll frames sent successfully using Selective Repeat ARQ!" << endl;
}

int main() {
    int choice;
    do {
        cout << "\n==============================\n";
        cout << " Sliding Window Mechanisms\n";
        cout << "==============================\n";
        cout << "1. Stop and Wait ARQ\n";
        cout << "2. Go-Back-N ARQ\n";
        cout << "3. Selective Repeat ARQ\n";
        cout << "4. Exit\n";
        cout << "------------------------------\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                stopAndWaitARQ();
                break;
            case 2:
                goBackNARQ();
                break;
            case 3:
                selectiveRepeatARQ();
                break;
            case 4:
                cout << "Exiting program..." << endl;
                break;
            default:
                cout << "Invalid choice! Please enter 1-4." << endl;
        }
    } while (choice != 4);

    cout << "\nProgram finished.\n";
    return 0;
}

____________________________________________________________________________________________________________________________________________________________________________________________
Subnet Calculator

#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int n;
    cout << "Enter number of subnets required: ";
    cin >> n;

    // We assume base network 192.168.1.0/24
    int networkBits = 24;
    int bitsNeeded = ceil(log2(n));      // Bits to borrow
    int newPrefix = networkBits + bitsNeeded;  // New CIDR
    int hostBits = 32 - newPrefix;
    int totalHosts = pow(2, hostBits);
    int usableHosts = totalHosts - 2;
    int increment = totalHosts;          // Subnet increment

    // Create subnet mask
    unsigned int mask = (0xFFFFFFFF << hostBits);
    int b1 = (mask >> 24) & 255;
    int b2 = (mask >> 16) & 255;
    int b3 = (mask >> 8) & 255;
    int b4 = mask & 255;

    cout << "\n===== SUBNETTING RESULT =====\n";
    cout << "Original Network : 192.168.1.0/24\n";
    cout << "Subnets Required : " << n << endl;
    cout << "Bits Borrowed    : " << bitsNeeded << endl;
    cout << "New Prefix       : /" << newPrefix << endl;
    cout << "Subnet Mask      : " << b1 << "." << b2 << "." << b3 << "." << b4 << endl;
    cout << "Hosts/Subnet     : " << usableHosts << " usable hosts\n\n";

    cout << "Subnet\tNetwork ID\t\tUsable Range\t\t\tBroadcast\n";

    int base = 0;
    for (int i = 1; i <= n; i++) {
        int networkID = base;
        int firstIP = base + 1;
        int lastIP = base + totalHosts - 2;
        int broadcast = base + totalHosts - 1;

        if (broadcast > 255) break;

        cout << i << "\t192.168.1." << networkID
             << "\t\t192.168.1." << firstIP << " - 192.168.1." << lastIP
             << "\t192.168.1." << broadcast << endl;

        base += increment;
    }

    return 0;
}

#include <iostream>
#include <cmath>
#include <sstream>
using namespace std;

// Parse IP string into int array
void parseIP(const string& ip, int parts[4]) {
    sscanf(ip.c_str(), "%d.%d.%d.%d", &parts[0], &parts[1], &parts[2], &parts[3]);
}

// Convert int array to string
string ipToString(int ip[4]) {
    stringstream ss;
    ss << ip[0] << "." << ip[1] << "." << ip[2] << "." << ip[3];
    return ss.str();
}

// Add increment to IP
void incrementIP(int ip[4], int inc) {
    int carry = inc;
    for (int i = 3; i >= 0 && carry > 0; i--) {
        int total = ip[i] + carry;
        ip[i] = total % 256;
        carry = total / 256;
    }
}

// Convert prefix ? subnet mask
void prefixToMask(int prefix, int mask[4]) {
    for (int i = 0; i < 4; i++) mask[i] = 0;

    for (int i = 0; i < prefix; i++)
        mask[i/8] |= (128 >> (i % 8));
}

// Calculate prefix from host requirement
int calculatePrefix(int hosts) {
    int bits = ceil(log2(hosts + 2)); // +2 for network & broadcast
    return 32 - bits;
}

int main() {
    int numNetworks, hostsPerNetwork;
    string baseIP;

    cout << "Enter number of networks: ";
    cin >> numNetworks;

    cout << "Enter number of systems per network: ";
    cin >> hostsPerNetwork;

    cout << "Enter base network IP (e.g., 192.168.0.0): ";
    cin >> baseIP;

    int currentIP[4];
    parseIP(baseIP, currentIP);

    int prefix = calculatePrefix(hostsPerNetwork);
    int mask[4];
    prefixToMask(prefix, mask);

    int blockSize = pow(2, 32 - prefix);

    cout << "\n--- Subnet Details ---\n";
    cout << "Hosts per network: " << hostsPerNetwork 
         << "  Prefix: /" << prefix << endl << endl;

    for (int net = 0; net < numNetworks; net++) {

        int startIP[4], endIP[4], network[4], broadcast[4];
        for (int i = 0; i < 4; i++)
            startIP[i] = currentIP[i];

        // Network address = current & mask
        for (int i = 0; i < 4; i++)
            network[i] = startIP[i] & mask[i];

        // End IP = start + blockSize - 1
        incrementIP(currentIP, blockSize - 1);
        for (int i = 0; i < 4; i++)
            endIP[i] = currentIP[i];

        // Broadcast = network | (255 - mask)
        for (int i = 0; i < 4; i++)
            broadcast[i] = network[i] | (255 - mask[i]);

        // First Host = network + 1
        int firstHost[4];
        for (int i = 0; i < 4; i++)
            firstHost[i] = network[i];
        firstHost[3]++;

        // Last Host = broadcast - 1
        int lastHost[4];
        for (int i = 0; i < 4; i++)
            lastHost[i] = broadcast[i];
        lastHost[3]--;

        int totalHosts = pow(2, 32 - prefix) - 2;

        cout << "Network " << net + 1 << ":\n";
        cout << "IP Range:          " << ipToString(startIP) << " - " << ipToString(endIP) << endl;
        cout << "Network Address:   " << ipToString(network) << endl;
        cout << "Broadcast Address: " << ipToString(broadcast) << endl;
        cout << "First Host:        " << ipToString(firstHost) << endl;
        cout << "Last Host:         " << ipToString(lastHost) << endl;
        cout << "Subnet Mask:       " << ipToString(mask) << endl;
        cout << "Total Hosts:       " << totalHosts << endl;
        cout << "-----------------------------------\n";

        // Move to next subnet start
        incrementIP(currentIP, 1);
    }

    return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DVR&&LSR
#include <iostream>
using namespace std;

#define INF 999

void DVR(int n, int cost[10][10]) {
    int dist[10][10], nextHop[10][10];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dist[i][j] = cost[i][j];
            nextHop[i][j] = j;
        }
    }

    int updated;
    do {
        updated = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    if (dist[i][j] > cost[i][k] + dist[k][j]) {
                        dist[i][j] = cost[i][k] + dist[k][j];
                        nextHop[i][j] = k;
                        updated = 1;
                    }
                }
            }
        }
    } while (updated);

    cout << "\n--- Distance Vector Routing Table ---\n";
    for (int i = 0; i < n; i++) {
        cout << "Router " << i + 1 << ":\n";
        for (int j = 0; j < n; j++) {
            cout << "To " << j + 1 << " via " << nextHop[i][j] + 1
                 << " distance = " << dist[i][j] << endl;
        }
        cout << endl;
    }
}

void LSR(int n, int cost[10][10]) {
    for (int src = 0; src < n; src++) {
        int dist[10], visited[10];
        for (int i = 0; i < n; i++) {
            dist[i] = cost[src][i];
            visited[i] = 0;
        }
        dist[src] = 0;
        visited[src] = 1;

        for (int count = 1; count < n - 1; count++) {
            int min = INF, u = -1;
            for (int i = 0; i < n; i++)
                if (!visited[i] && dist[i] < min) {
                    min = dist[i];
                    u = i;
                }
            visited[u] = 1;
            for (int v = 0; v < n; v++) {
                if (!visited[v] && dist[v] > dist[u] + cost[u][v])
                    dist[v] = dist[u] + cost[u][v];
            }
        }
        cout << "\nRouting Table for Node " << src + 1 << ":\n";
        for (int i = 0; i < n; i++)
            cout << "To " << i + 1 << " distance = " << dist[i] << endl;
    }
}

int main() {
    int n, choice;
    int cost[10][10];
    char ch;

    cout << "Enter number of nodes: ";
    cin >> n;

    cout << "Enter cost matrix (use 999 for no direct link):\n";
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> cost[i][j];
        }
    }

   do{
     cout << "\nSelect Routing Algorithm:\n";
    cout << "1. Distance Vector Routing (DVR)\n";
    cout << "2. Link State Routing (LSR)\n";
    cout << "Enter your choice: ";
    cin >> choice;

    switch (choice) {
        case 1:
            DVR(n, cost);
            break;
        case 2:
            LSR(n, cost);
            break;
        default:
            cout << "Invalid choice!";
    }
    cout<<"do you want to continue(y/n): ";
    cin>>ch;
   }while(ch == 'y' || ch == 'Y');

    return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
tcp_server
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
using namespace std;

int main() {
    int serverSocket, newSocket;
    char buffer[1024];

    // Create socket
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(8080);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    // Bind
    bind(serverSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr));

    // Listen
    listen(serverSocket, 3);
    cout << "Server waiting for connection..." << endl;

    socklen_t addrSize = sizeof(serverAddr);
    newSocket = accept(serverSocket, (struct sockaddr*)&serverAddr, &addrSize);
    cout << "Client connected!" << endl;

    while (1) {
        memset(buffer, 0, sizeof(buffer));

        // Receive message from client
        int val = read(newSocket, buffer, 1024);
        if (val <= 0) {
            cout << "Client disconnected." << endl;
            break;
        }
        cout << "Client: " << buffer << endl;

        // Send reply
        cout << "Server: ";
        string reply;
        getline(cin, reply);

        send(newSocket, reply.c_str(), reply.length(), 0);
    }

    close(newSocket);
    close(serverSocket);
    return 0;
}
-------------------------------------------------------------------------------
tcp_client
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
using namespace std;

int main() {
    int clientSocket;
    char buffer[1024];

    // Create socket
    clientSocket = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(8080);
    serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1");

    // Connect
    connect(clientSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr));
    cout << "Connected to Server!" << endl;

    while (1) {
        // Send message to server
        cout << "Client: ";
        string msg;
        getline(cin, msg);

        send(clientSocket, msg.c_str(), msg.length(), 0);

        memset(buffer, 0, sizeof(buffer));

        // Receive reply
        int val = read(clientSocket, buffer, 1024);
        if (val <= 0) {
            cout << "Server disconnected." << endl;
            break;
        }

        cout << "Server: " << buffer << endl;
    }

    close(clientSocket);
    return 0;
}
